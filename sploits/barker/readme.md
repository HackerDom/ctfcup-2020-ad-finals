# Barker
Сервис предназначен для публикации коротких сообщений - Барков (в терминах сервисов). Такие сообщения бывают двух типов публичные и приватные. Под каждым барком можно оставлять комментарии двух типов - публичные и приватные. Флаги кладутся в приватные комментарии и приватные флаги. Сервис содержит веб-интерфейс и api.

# Уязвимость 1
Первая уязвимость заключается в отсутствии достаточных проверок аутентификации при обработке запроса `/get_bark/<bark_id>`, в связи с этим становится возможно получать информацию из приватных барков.
Простым перебором `bark_id` получаем флаг.

# Уязвимость 2
Приватные барки доступны для просмотра друзьям пользователя, который опубликовал запись, однако в сервисе заложена уязвимость позволяющая добавлять пользователей в друзья без подтверждения. Это становится возможно в связи с тем, что по умолчанию отношение дружбы в базе данных считается подтвержденным. Ниже представлен код модели, объявляющей таблицу.
``` python
class Friendship(models.Model):
    ...
    status = models.BooleanField(default=True)
```

# Уязвимость 3
Позволяет просмотреть все комментарии (как публичные, так и приватные) для барков. Это становится возможно в связи с недостатками проверок при обработке запроса в API по адресу `/api/comments/<bark_id>/`, важно получить перед этим токен доступа для произвольного пользователя.

# Уязвимость 4
Для доступа к API сервиса используются специальные токены, которые можно генерировать в профиле пользователя. Данная уязвимость заключается в предсказуемом генераторе API-токенов. В обработчике для запросов по адресу `/generate_token/` используется следующая схема создания токенов на псевдокоде.
```
md5(username + str(next(MainConfig.generator)))
```
Здесь происходит вызов ГПСЧ, код которого представлен в файле с конфигом приложения.
``` python
def get_generator():
    state = [24432, 0]
    while True:
        n = ""
        for _ in range(32):
            s = bin(state[0] & 214748361).count("1") + state[1]
            state[0] = (state[0] >> 1) | ((s & 1) << 8)
            state[1] = s >> 1
            n += str(state[0] & 1)
        yield int(n, base=2)
```

Данный ГПСЧ генерирует ограниченное число комбинаций. Всего 293 различных генерации 32 битных чисел. Это дает возможность предсказывать последующие комбинации, восстановив текущее состояние генератора.
